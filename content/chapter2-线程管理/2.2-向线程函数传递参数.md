# 2.2 向线程函数传递参数

## 线程函数传递参数要避免隐式转换：
```
#include <thread>
#include <string>

void f(int i, std::string const& s)
{
}
void oops(int some_param)
{
    char buffer[1024]; // 1
    std::thread t(f, 3, buffer); // 2 //隐式转换
    t.detach();
}

void not_oops(int some_param)
{
    char buffer[1024]; // 1
    std::thread t(f, 3, std::string(buffer)); // 2 //显示转换 // 使用std::string，避免悬垂指针
    t.detach();
}

int main()
{
    oops(2);
}

//线程函数传递参数要避免隐式转换<-可能参数还没转换完就被销毁了
```

## 线程函数传递引用参数必须使用`std::ref`：

```
#include <thread>
#include <string>
#include <iostream>

void update_data_for_widget(int w, std::string& data)// 1
{
    data = "not happy!";
}
void display_status()
{

}
void process_string(std::string data)
{
    std::cout << data << "\n";
}
void oops_again(int w)
{
    //std::string data="Happy!";
    //std::thread t(update_data_for_widget, w, data); // 2
    //display_status();
    //t.join();
    //process_string(data); // 3
}
void not_oops_again(int w)
{
    std::string data = "Happy!";
    std::thread t(update_data_for_widget, w, std::ref(data)); // 2
    display_status();
    t.join();
    process_string(data); // 3
}
int main()
{
    not_oops_again(2);
}

//线程函数传递引用参数必须使用std::ref<-不然可能编译都不能通过
//ref->reference->引用
//std::cref->const reference->常数引用
```

## 新线程将my_x.do_lengthy_work(int)作为线程函数；my_x的地址①作为指针对象提供给函数，`std::thread`构造函数的第三个参数就是成员函数的第一个参数，以此类推：

```c++
class X
{
public:
  void do_lengthy_work(int);
};
X my_x;
int num(0);
std::thread t(&X::do_lengthy_work, &my_x, num);
```

## `std::move`转移一个动态对象到一个线程中去：

```c++
void process_big_object(std::unique_ptr<big_object>);

std::unique_ptr<big_object> p(new big_object);
p->prepare_data(42);
std::thread t(process_big_object,std::move(p));

//在`std::thread`的构造函数中指定`std::move(p)`,big_object对象的所有权就被首先转移到新创建线程的的内部存储中，之后传递给process_big_object函数
```
## 
`std::thread`实例的*可移动*且*不可复制*性。不可复制保性证了在同一时间点，一个`std::thread`实例只能关联一个执行线程；可移动性使得程序员可以自己决定，哪个实例拥有实际执行线程的所有权。
